# 3.1 sort —— 排序算法 #

该包实现了3种基本排序算法：插入排序、堆排序和快速排序。
但是这三种排序方法是不公开的，它们只被用于sort包内部使用。所以在对数据集合排序时不必考虑应当选择哪一种排序方法，只要实现了sort.Interface定义的三个方法：获取数据集合长度的Len()方法、比较两个元素大小的Less()方法和交换两个元素位置的Swap()方法，就可以顺利对数据集合进行排序。sort包会根据实际数据自动选择高效的排序算法。
除此之外，为了方便对常用数据类型的操作，sort包提供了对[]int切片、[]float64切片和[]string切片完整支持，主要包括：
- 对基本数据类型切片的排序支持
- 基本数据元素查找
- 判断基本数据类型切片是否已经排好序
- 对排好序的数据集合逆序

## 3.1.1 数据集合排序 ##

前面已经提到过，对数据集合（包括自定义数据类型的集合）排序需要实现sort.Interface接口的三个方法，我们看以下该接口的定义：

	type Interface interface {
    		// 获取数据集合元素个数
    		Len() int
    		// 如果i索引的数据小于j所以的数据，返回true，不会调用
			// 下面的Swap()，即数据升序排序。
    		Less(i, j int) bool
    		// 交换i和j索引的两个元素的位置
		Swap(i, j int)
	}
	
数据集合实现了这三个方法后，即可调用该包的Sort()方法进行排序。
Sort()方法定义如下：
	
        func Sort(data Interface)

Sort()方法惟一的参数就是带排序的数据集合。

该包还提供了一个方法可以判断数据集合是否已经排好顺序，该方法的内部实现依赖于我们自己实现的Len()和Less()方法：

    func IsSorted(data Interface) bool {
        n := data.Len()
        for i := n - 1; i > 0; i-- {
            if data.Less(i, i-1) {
                return false
            }
        }
        return true
    }

下面是一个使用sort包对学生成绩排序的示例：

```golang
package main

import (
	"fmt"
	"sort"
)

//学生成绩结构体
type StuScore struct {
     //姓名
    name  string
    //成绩
    score int
}

type StuScores []StuScore

//Len()
func (s StuScores) Len() int {
	return len(s)
}

//Less():成绩将有低到高排序
func (s StuScores) Less(i, j int) bool {
	return s[i].score < s[j].score
}

//Swap()
func (s StuScores) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

func main() {
    stus := StuScores{
                {"alan", 95},
                {"hikerell", 91},
                {"acmfly", 96},
                {"leao", 90}}

    fmt.Println("Default:")
    //原始顺序
    for _, v := range stus {
        fmt.Println(v.name, ":", v.score)
    }
    fmt.Println()
    //StuScores已经实现了sort.Interface接口
    sort.Sort(stus)
    
    fmt.Println("Sorted:")
     //排好序后的结构
    for _, v := range stus {
        fmt.Println(v.name, ":", v.score)
    }

    //判断是否已经排好顺序，将会打印true
    fmt.Println("IS Sorted?", sort.IsSorted(stus))
}
```
程序该示例程序的自定义类型StuScores实现了sort.Interface接口，所以可以将其对象作为sort.Sort()和sort.IsSorted()的参数传入。运行结果：  

    ======Default======
    alan : 95
    hikerell : 91
    acmfly : 96
    leao : 90
    
    ======Sorted=======
    leao : 90
    hikerell : 91
    alan : 95
    acmfly : 96
    IS Sorted? true

该示例实现的是升序排序，如果要得到降序排序结果，其实只要修改Less()函数：
```golang
//Less():成绩降序排序,只将小于号修改为大于号
func (s StuScores) Less(i, j int) bool {
	return s[i].score > s[j].score
}
```
此外，*sort*包提供了Reverse()方法，可以允许将数据按Less()定义的排序方式逆序排序，而不必修改Less()代码。方法定义如下：

    func Reverse(data Interface) Interface

我们可以看到Reverse()返回的一个sort.Interface接口类型，整个Reverse()的内部实现比较有趣：
```golang
    //定义了一个reverse结构类型，嵌入Interface接口
    type reverse struct {
        Interface
    }

    //reverse结构类型的Less()方法拥有嵌入的Less()方法相反的行为
    //Len()和Swap()方法则会保持嵌入类型的方法行为
    func (r reverse) Less(i, j int) bool {
        return r.Interface.Less(j, i)
    }

    //返回新的实现Interface接口的数据类型
    func Reverse(data Interface) Interface {
        return &reverse{data}
    }
```
了解内部原理后，可以在学生成绩排序示例中使用Reverse()来实现成绩升序排序：
```golang
    sort.Sort(sort.Reverse(stus))
     for _, v := range stus {
        fmt.Println(v.name, ":", v.score)
    }
```

## 3.1.2 *sort*包已经支持的内部数据类型排序

前面已经提到，*sort*包原生支持[]int、[]float64和[]string三种内建数据类型切片的排序操作，即不必我们自己实现相关的Len()、Less()和Swap()方法。

**1. []int切片及IntSlice类型**  
**2. []float64切片及Float64Slice类型**  
**3. []string切片及StringSlice类型**
